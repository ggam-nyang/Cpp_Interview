## 오프라인 데이터 샘플 구하기
서로 다른 원소로 이루어진 배열과 부분 집합의 크기가 주어졌을 때, 주어진 크기의 부분 집합을 반환하는 알고리즘을 작성하라.

모든 부분 집합이 생성될 확률은 동일해야한다.  

### 1차
부분 집합을 구하는 문제이다. 0 ~ n-1의 수에서 k개의 수를 뽑으면 된다 (인덱스)

총 조합의 개수는 nCk 일 것이고, 실제로 해당 부분집합을 구하는 방법을 고안해야한다.  
모든 조합을 구하고, 난수로 몇번째 조합을 선택할지 정할 수 있지만 메모리가 비효율적이다.

shuffle을 이용해, 배열을 섞고 앞에서부터 k개의 개수를 선택할 수 있을 것이다.
약 437ms가 걸렸다.

### 해법
0~ n-1까지 난수를 뽑고, 1 ~ n-1중에 뽑고... 이렇게 반복한다.
(shuffle과 유사하지만 난수를 k번 뽑는다. 그리고 k번만 스왑한다)
50ms로 훨씬 효율적인 시간내에 구할 수 있었다.

시간 O(k), 공간 O(1)이다.
k > n / 2일 경우 뽑은 난수를 제거하는 방식으로 구현하면 최적화할 수 있다.


### 응용
rand() 함수는 [0, RAND_MAX - 1]사이의 값을 동일한 확률로 반환한다.  
rand() % n은 [0, n-1] 사이의 값을 동일한 확률로 반환한다고 할 수 있나?

아니라고 생각한다. RAND_MAX - 1이 n의 배수가 아니기 때문이다. 그러나 수가 커질수록 거의 동일한 수치에 수렴할 것이다.

#### 난수
난수 생성은 어떻게 가능한걸까?

- random_device: 시스템의 엔트로피 소스를 사용하여 진정한 난수를 생성합니다. 이 엔트로피 소스는 하드웨어나 OS에 따라 다를 수 있으며, 보통 매우 예측 불가능한 값을 제공합니다. 
- random_engine: 특정 알고리즘을 사용하여 의사 난수를 생성합니다. 이 난수는 시드에 의존하며, 같은 시드를 사용할 경우 동일한 난수 열을 생성합니다. 메르센 트위스터 알고리즘(std::mt19937)은 널리 사용되는 난수 생성 알고리즘 중 하나로, 빠르고 긴 주기를 가지는 것이 특징입니다.

대충 느낌은 알겠지만, 난수 생성 알고리즘을 깊게 알긴 어려울 것 같다. 우선 C++에서의 사용법 정도를 익혀두자.
