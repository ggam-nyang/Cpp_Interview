## 배열에서 이동하기
길이가 n인 배열 A가 주어졌을 때, 배열의 시작점에서 마지막 지점까지 도달할 수 있는지 판단하는 프로그램을 작성하라.  
단, A[i]는 i번째 위치에서 나아갈 수 있는 최대 거리를 뜻한다.

예시)
A = {3, 3, 1, 0, 2, 0, 1}

### 1차
dfs가 가장 먼저 떠올랐다. dfs를 이용할 경우, 도착 경로를 모두 알 수 있다.  
dfs와 bfs의 경우, 연결이 안된 구간이 앞쪽에 많을 수록 bfs가 유리하다.

우선 bfs로 구현하였다.

### 힌트
시작점부터 시작해서 각 위치를 잘 분석해 보자.

음... 어떤 힌트인지 잘 와닿지 않는다.
우선 bfs/dfs의 경우 visited 체크를 통해 최대 O(n)이다!

### 해법
배열 A의 모든 원소를 확인하긴 해야한다.  
때문에 각 위치에서 최대한 움직일 수 있는 위치를 기록한다 (dp 느낌)  

예를 들어, A = 3, 3, 1, 0, 2, 0, 1이면  0, 3, 4, 4, 6, 6, 7이 된다.

코드 구현은 CanReach2()와 같다.

이 방식은 특이한게, for문의 조건이 `i <= furthest_reach_so_far && furthest_reach_so_far < last_index` 이렇다.

furthest_reach_so_far는 현재 확인한 최대 갈 수 있는 거리로 for문 내에서 값이 변한다.
정말 간결하게 코드를 구성했다....


### 응용
마지막 위치에 도달할 수 있는 최소한의 움직임을 계산하는 프로그램을 작성하라. 

이 부분이 dfs, bfs와 같은 탐색을 통해 이동 경로를 저장하여 풀 수 있을 것이다.  

해법과 유사한 형태에서 발전시킬 방법은 떠오르지 않는다..!



