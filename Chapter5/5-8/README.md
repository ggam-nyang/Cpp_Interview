## 대체 연산
n개의 숫자를 원소로 가지는 배열 A를, B[0] <= B[1] >= B[2] <= B[3] >= B[4] ... 의 특징을 가지도록, 새로운 배열 B에 재배치하라.

### 1차 풀이
n의 크기는 10만 정도의 숫자라고 가정하자. 그리고 B의 크기는 최대한 크게 만드는 것이 목표라고 가정하자. (이게 당연해 보인다.)  
A의 원소를 작은 원소, 큰 원소, 작은원소, 큰원소를 반복해서 삽입해야한다.  
이때 B에 가장 많은 원소를 넣으려면 정렬된 A에서 왼쪽, 오른쪽 값을 하나씩 넣으면 된다.  

정렬은 O(n * log(n))의 시간 복잡도를 가지고, 삽입에는 O(n)이 걸리므로 결국 O(n * log(n))의 시간 복잡도를 가질 것이다.
정렬된 데이터에서 원소의 개수가 홀/짝에 따라 좌측 작은 값 부분 배열과 우측 큰 값 부분 배열을 섞어준다. 

#### 테스트 결과
평균 7us 시간으로 203개의 테스트가 통과됐다.  

### 해법
정렬 후 1차 풀이 방식 or 0, 1번 교체, 2, 3번 교체 방식으로 2개씩 교체하는 방법이 가장 간단하다.  

그런데 정렬을 하지 않는 방법이 존재한다....!!

### 해법 1
중간값 찾기를 이용한다.  중간값 주위의 원소를 재배열하고 교차 배치를 한다.(O(n))  
이 방법은 11절에 나오는데, 자세히 이해하지 못했다..   
모든 원소의 중간값을 구하여, 그 값보다 작고, 큰 값을 기준으로 교차 배치를 하는 방법같다.

### 해법 2
이 방법은 더 효율적이고 (크게는 아니지만) 간단하다.   
결국 정렬의 근본적 원리를 이용하는 것인데, 버블정렬처럼 순회하며 변경해주는 것이다. 인덱스에 대해  
- 홀수일 경우, A[i] < A[i - 1] 이어야 하고, 그렇지 않다면 둘을 변경한다.
- 짝수일 경우, A[i] > A[i - 1] 이어야 하고, 그렇지 않다면 둘을 변경한다.     



결국 버블 정렬에 조건을 추가한 느낌인데, 단순히 버블정렬을 익힌 것이 아닌 깊게 이해했다면 떠올릴 수 있는 해법이었다.  
역시 중요한건 근본이다.  

테스트 결과 평균 5us로 2us 개선되었다.