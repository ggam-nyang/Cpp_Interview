## 주식 한 번 사고팔기
40일간의 일자별 최고가, 최저가, 시작가에 대한 정보가 있다. 특정 기간, 주식 한 주를 사서 되팔았을 때 최대 이익을 얻을 수 있는 알고리즘을 설계하라.

예를 들어 {310, 315, 275, 295, 260, 270, 290, 230, 255, 250}이 주어지면 (하루의 가격 변동)  
260 -> 290 에 파는 것이 최대 효율이다. 

어떤 회사의 일일 주식 가격이 배열로 주어졌을 때 한 주를 한 번 사고팔아서 남길 수 있는 최대 이익을 구해 보자.


### 1차
가장 무식한 방법을 떠올려보자. O(n^2)으로 산 주식에 대해 뒤의 모든 매도가와 비교하는 방법이다.  
그러나 일일 주식 가격이 10만건 이상이라면, 비효율적인 알고리즘이 된다.  
때문에 슬라이딩 윈도우(투 포인터..!)를 사용하여 O(n)으로 구현을 생각해봤다.  

매입가(좌측)와 매도가(우측)을 지정 후, 우측 포인터만 움직이며 좌측 값보다 큰 경우 최대 이익과 비교하여 저장한다.  
매입가보다 더 작은 가격이 나올 경우, 좌측 포인터를 이동하고 다시 매도가를 찾는다.  

이게 가능한 이유는, 매입가가 더 작은 경우로 변경했을 때 더 큰 이익이 나는 경우가 없기 때문이다.  
(그리디처럼, 좌측 포인터를 옮기면서 그 사이의 이익을 측정하지 못하는데 그 사이 값들은 모두 더 작다고 확신할 수 있다)

ps) 주어진 1개의 예제에 대해서는 확인이 가능한데... 아무래도 문제로 주어지는 것이 아닌게 아쉽다.

### 해법
분할 정복 알고리즘도 가능하다.  
왼쪽, 오른쪽 배열로 분할 후 (왼쪽 배열의 최대 이익, 오른쪽 배열의 최대 이익, 왼쪽 배열 최소값과 오른쪽 배열 최대값의 차이) 3가지 값을 비교하면 된다.  

현재까지의 최저가를 기록하여 비교하는 방법은 가장 간단하고 O(n)의 효율을 가진다.
getMaxProfit2()를 참고하자.  

이 방법은 1차 풀이와 유사하다. 그러나 내 풀이는 인덱스를 사용했고, 이 풀이는 배열의 값만 사용했다.  

### 응용
배열이 주어졌을 때, 연속한 값이 같은 부분 배열 중 길이가 가장 긴 부분 배열의 길이를 구하는 프로그램을 작성하라.

해법의 풀이와 유사하게 모든 원소를 탐색한다. 이때, 현재 원소의 값을 저장하고 동일하면 카운트하여 최대 카운트와 비교한다. 동일하지 않은 값이라면 카운트를 초기화한다.

