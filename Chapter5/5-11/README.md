## 다음 순열 구하기
n개의 원소로 만들 수 있는 순열의 개수는 n!이다. 이 순열들은 사전순으로 정렬이 가능하다.  
예를 들어, <2, 1, 0> 은 <2, 0, 1>보다 사전순으로 뒤에 위치한다.

어떤 순열에 대해서, 그 다음 순열을 구하는 프로그램을 작성하라.

### 1차
a, b, c, d, e .. 순열 arr에 대해서  arr[i] < arr[i + 1]인 경우를 생각해봤다.  
이런 경우, arr는 더 커질 여지가 있는 것이다. 이 최초의 i를 찾고,  i + 1부터 끝까지에 대해 다음 순열을 구한다.  

바꿔 생각하면 맨 뒤부터 탐색하여 arr[i] < arr[i + 1] 인 경우를 찾는다. 그렇다면  0 ~ i-1까지는 완성된 수열이고, i ~ n까지 순열의 다음 순열을 찾아야한다.

후자의 부분수열은 453210처럼 첫 두개의 원소만 순서가 반전되어 있을 것이다.  이 순열의 다음 순열을 구하면 된다.  
이 경우에는 53210을 01235로 뒤집고, 마지막 원소 5와 맨앞 4를 변경하여 501234가 된다.  
일반적으로는, arr[i]보다 큰 수 중 가장 작은 수와 swap하고 아래 배열을 오름차순 정렬하면 된다.

##### 테스트
테스트 결과는 모두 1us 미만으로 통과했다.  

테스트 케이스를 계속 돌려보며 알고리즘을 수정할 수 있는데, 이게 학습에 도움이 되는지 고민이 좀 된다...!  
알고리즘의 틀린 부분을 너무 쉽게 찾아주기 때문...!  

반복문이 2개지만, 내부 반복문은 조건이 맞는 경우 1회만 실행된다.
시간 복잡도: O(nlogn ~ n) 느낌
공간 복잡도: O(1)

### 해법
n에 대한 모든 순열을 구하고, 그 다음 순열을 찾을 수 있다.  그러나 이건 시간 및 공간이 매우 비효율적이다  
심지어 구현도 단순하지 않다.  

가장 긴 감소순열을 찾는다. (뒤에서부터 찾는 것과 같은 방식)  
이후 내 방식과 같이 arr[i]보다 큰 수 중 가장 작은 수와 스왑한다.  
이를 통해, 접미사를 최소한으로 증가시킨 꼴이다.  

정렬을 최적화 한다면, 배열을 뒤집으면 된다.  

역시나 해답의 코드는 맛있는 라이브러리 함수와 깔끔한 코드로 짜여져있다......
