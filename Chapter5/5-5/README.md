## 정렬된 배열에서 중복 제거하기
정렬된 배열에서 반복되는 원소를 제거하는 문제.  
예를 들어, {2, 3, 5, 5, 7, 11, 11, 11, 13}에서 {2, 3, 5, 7, 11, 13, 0, 0, 0}  

정렬된 배열이 입력으로 주어졌을 때 중복된 원소를 모두 제거한 뒤, 비어 있는 공간이 생기지 않도록 유효한 원소들을 모두 왼쪽으로 시프트하는 프로그램을 작성하라.  
유효한 원소의 개수를 반환하면 된다.  

### 1차
원소를 순회하며 배열에서 제거한다. 제거가 빈번히 발생하므로 list를 사용하고, 뒤에 원소를 추가하는 방식으로 구현했다.  
정렬이 되어 있으므로, 더 작은 원소가 나타나면 종료한다.

list의 erase, iterator를 다루는데 있어 코드가 지저분해졌다.  
O(n)의 시간복잡도와 기존에 제공된 list의 크기만큼만 사용하므로 O(1)의 공간복잡도로 추측한다.


### 힌트
O(n) 시간복잡도와 O(1) 공간 복잡도 해법이 존재한다.

내가 푼 방식이 맞는 것 같다..!

### 해법
공간을 넉넉히 사용한다면, Set을 사용해서 집어넣으면 된다.

공간을 O(1)만큼 사용하면서 자료구조에 도움을 받지 않는 방법은 swap을 통해 가능하다.

### 2차
해법의 방식이다. removeDuplicate2()  
일종의 버블 정렬과 유사하게, 동일하지 않은 값이면 왼쪽으로 이동하고, 중복된 값이면 오른쪽으로 이동하는 방식..!

### 응용1
배열과 키가 주어졌을 때, 입력받은 키와 같은 원소를 배열에서 모두 삭제하고 남아 있는 원소를 왼쪽으로 시프트하는 함수를 작성하라.
`removeDuplicate3(int key)`

해법의 방식을 완전히 이해하게 됐다!!!

### 응용2
정렬된 배열 A와 정수 m이 주어졌을 때, m번 등장하는 원소 x를 min(2, m)번 등장하게끔 바꿔 주는 프로그램을 작성해 보자.

2차 풀이와 유사하게 푼다. 다만, 최소 2번까지의 등장은 보장하므로  등장 count 변수를 하나 생성하고, 
이 count가 2보다 클 경우엔 write_index 포인터를 이동하는 방식으로 구현할 수 있다.


결국 투 포인터를 이용하고, 조건을 변경하거나 추가 변수를 활용해 시간 복잡도 O(n), 공간 복잡도 O(1)로 구현할 수 있다.




